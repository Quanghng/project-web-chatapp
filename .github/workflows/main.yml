name: CI/CD Pipeline

on:
  push:
    branches:
      - feature/cicd # Trigger on pushes to the main branch (e.g., after merging a PR)
  pull_request:
    branches:
      - feature/cicd # Trigger on pull requests targeting the main branch (for CI checks)

env:
  # Base image names (will be prefixed with GHCR path later)
  # These names should match the `image:` key you might use in your docker-compose.yml
  # if you don't use 'build:' exclusively, or if you tag the local build.
  BACKEND_IMAGE_NAME: chatapp_backend
  FRONTEND_IMAGE_NAME: chatapp_frontend

jobs:
  ci:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Set a timeout for the CI job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js (for backend/frontend npm commands)
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Specify your Node.js version

      - name: Set up Docker Buildx (for efficient Docker builds and caching)
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # --- Backend CI Steps ---
      # Start only the services needed for backend tests, leveraging docker-compose
      # Wait for healthchecks to pass, giving services time to fully initialize
      - name: Start dependent services for Backend Tests
        run: |
          docker compose -f docker-compose.yml up -d postgres redis rabbitmq
          echo "Waiting for PostgreSQL, Redis, and RabbitMQ services to be healthy..."
          docker compose -f docker-compose.yml wait postgres rabbitmq redis
          echo "Dependent services are healthy."
        # Use healthcheck values from docker-compose.yml; adjust wait time if services are slow to start

      - name: Install backend dependencies
        run: npm install
        working-directory: ./backend

      - name: Apply Prisma Migrations for Tests
        # This step runs prisma migrations against the temporary test database
        run: npx prisma migrate deploy
        working-directory: ./backend
        env:
          # Ensure this DATABASE_URL points to the postgres service running in the CI runner's Docker network
          DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/chatapp?schema=public
          # The secrets for POSTGRES_USER/PASSWORD must be available in GitHub Secrets

      - name: Run backend tests
        run: npm test
        working-directory: ./backend
        env:
          # Expose necessary environment variables for tests from GitHub Secrets
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: 5672
          DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/chatapp?schema=public
          RABBITMQ_URL: amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@localhost:5672
          JWT_ACCESS_TOKEN_SECRET: ${{ secrets.JWT_ACCESS_TOKEN_SECRET }}
          JWT_REFRESH_TOKEN_SECRET: ${{ secrets.JWT_REFRESH_TOKEN_SECRET }}
          CSRF_SECRET: ${{ secrets.CSRF_SECRET }}
          CSRF_COOKIE_NAME: ${{ secrets.CSRF_COOKIE_NAME }}
          TOKEN_COOKIE_MODE: ${{ secrets.TOKEN_COOKIE_MODE }}
          NODE_ENV: test 

      - name: Build and push Backend Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          # Tag with full GHCR path and commit SHA for unique versioning
          tags: ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha # Use GitHub Actions cache for faster builds
          cache-to: type=gha,mode=max # Store build cache in GitHub Actions

      # --- Frontend CI Steps ---
      - name: Install frontend dependencies
        run: npm install
        working-directory: ./frontend

      - name: Build frontend static files
        run: npm run build
        working-directory: ./frontend

      - name: Build and push Frontend Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          # Tag with full GHCR path and commit SHA for unique versioning
          tags: ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          # Pass VITE environment variables as build arguments for production build
          build-args: |
            VITE_API_BASE_URL=${{ secrets.FRONTEND_API_BASE_URL_PROD }}
            VITE_GRAPHQL_HTTP_URL=${{ secrets.FRONTEND_API_BASE_URL_PROD }}/graphql
            # Replace http with ws for WebSocket URL
            VITE_GRAPHQL_WS_URL=${{ secrets.FRONTEND_API_BASE_URL_PROD | replace('http', 'ws') }}/graphql
          cache-from: type=gha
          cache-to: type=gha,mode=max

  cd:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: ci # This job depends on the 'ci' job completing successfully
    environment: production # Assign to an environment for tracking deployments (optional)
    timeout-minutes: 10 # Set a timeout for the CD job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy with SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          # Navigate to the application directory on the server
          script: |
            echo "Navigating to ${{ secrets.APP_DIR }}..."
            cd ${{ secrets.APP_DIR }} || { echo "Error: Application directory not found on server."; exit 1; }
            echo "Logging in to GitHub Container Registry..."
            echo ${{ secrets.DOCKER_PASSWORD }} | docker login ghcr.io -u ${{ secrets.DOCKER_USERNAME }} --password-stdin || { echo "Error logging into GHCR."; exit 1; }

            # git pull origin main || { echo "Error pulling latest code."; exit 1; }

            echo "Stopping and removing old containers..."
            docker compose down --volumes --remove-orphans

            echo "Pulling latest backend image: ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
            docker pull ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} || { echo "Error pulling backend image."; exit 1; }
            docker tag ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} nestjs:latest

            echo "Pulling latest frontend image: ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
            docker pull ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} || { echo "Error pulling frontend image."; exit 1; }
            docker tag ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} frontend:latest

            echo "Starting services using Docker Compose..."
            docker compose --env-file ./.env up -d --remove-orphans || { echo "Error starting services."; exit 1; }

            echo "Waiting for NestJS backend service to become healthy..."
            for i in {1..15}; do # Try up to 15 times (150 seconds total wait)
              HEALTH_STATUS=$(docker inspect -f '{{.State.Health.Status}}' nestjs 2>/dev/null || true)
              if [ "$HEALTH_STATUS" == "healthy" ]; then
                echo "NestJS service is healthy!"
                break
              else
                echo "NestJS service status: $HEALTH_STATUS. Waiting 10 seconds (attempt $i/15)..."
                sleep 10
              fi
              if [ $i -eq 15 ]; then
                echo "NestJS service did not become healthy within the timeout. Deployment might be incomplete."
                exit 1 # Fail the job if health check doesn't pass
              fi
            done

            echo "Running Prisma Migrations on the deployed backend service..."
            docker compose exec nestjs npx prisma migrate deploy || { echo "Error running Prisma migrations."; exit 1; }

            echo "Deployment complete!"