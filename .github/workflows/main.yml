name: CI/CD Pipeline

on:
  push:
    branches:
      - feature/cicd
  pull_request:
    branches:
      - feature/cicd

env:
  BACKEND_IMAGE_NAME: chatapp_backend
  FRONTEND_IMAGE_NAME: chatapp_frontend

jobs:
  ci:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Create dummy .env for Docker Compose in CI
        run: |
          # This creates a minimal .env file to prevent Docker Compose errors
          # when it tries to read the env_file property for services not directly started.
          # These values don't need to be real secrets, just present.
          echo "POSTGRES_USER=testuser" > ./.env
          echo "POSTGRES_PASSWORD=testpassword" >> ./.env
          echo "RABBITMQ_USER=testuser" >> ./.env
          echo "RABBITMQ_PASSWORD=testpassword" >> ./.env
          echo "JWT_ACCESS_TOKEN_SECRET=dummy_jwt_access" >> ./.env
          echo "JWT_REFRESH_TOKEN_SECRET=dummy_jwt_refresh" >> ./.env
          echo "CSRF_SECRET=dummy_csrf_secret" >> ./.env
          echo "CSRF_COOKIE_NAME=dummy_csrf_cookie" >> ./.env
          echo "TOKEN_COOKIE_MODE=dummy_token_mode" >> ./.env
          echo "NODE_ENV=development" >> ./.env # Default to development for Docker Compose parsing
          # Add any other variables that are *referenced* in docker-compose.yml via ${VAR} syntax
          # even if they are defined in .env, they need a placeholder for parsing.
          echo "FRONTEND_URL=http://localhost" >> ./.env # Example if referenced
          
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Start dependent services for Backend Tests
        run: |
          docker compose -f docker-compose.yaml up -d postgres redis rabbitmq
          echo "Waiting for PostgreSQL, Redis, and RabbitMQ services to be healthy..."
          docker compose -f docker-compose.yaml wait postgres rabbitmq redis
          echo "Dependent services are healthy."

      - name: Install backend dependencies
        run: npm install
        working-directory: ./backend

      - name: Apply Prisma Migrations for Tests
        run: npx prisma migrate deploy
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/chatapp?schema=public

      - name: Run backend tests
        run: npm test
        working-directory: ./backend
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: 5672
          DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/chatapp?schema=public
          RABBITMQ_URL: amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@localhost:5672
          JWT_ACCESS_TOKEN_SECRET: ${{ secrets.JWT_ACCESS_TOKEN_SECRET }}
          JWT_REFRESH_TOKEN_SECRET: ${{ secrets.JWT_REFRESH_TOKEN_SECRET }}
          CSRF_SECRET: ${{ secrets.CSRF_SECRET }}
          CSRF_COOKIE_NAME: ${{ secrets.CSRF_COOKIE_NAME }}
          TOKEN_COOKIE_MODE: ${{ secrets.TOKEN_COOKIE_MODE }}
          NODE_ENV: test 

      - name: Build and push Backend Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install frontend dependencies
        run: npm install
        working-directory: ./frontend

      - name: Build frontend static files
        run: npm run build
        working-directory: ./frontend
      
      - name: Build and push Frontend Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          build-args: |
            VITE_API_BASE_URL=${{ secrets.FRONTEND_API_BASE_URL_PROD }}
            VITE_GRAPHQL_HTTP_URL=${{ secrets.FRONTEND_API_BASE_URL_PROD }}/graphql
            VITE_GRAPHQL_WS_URL=${{ env.WS_URL }}/graphql
          cache-from: type=gha
          cache-to: type=gha,mode=max

  cd:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: ci
    environment: production
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy with SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Navigating to ${{ secrets.APP_DIR }}..."
            cd ${{ secrets.APP_DIR }} || { echo "Error: Application directory not found on server."; exit 1; }

            echo "Logging in to GitHub Container Registry..."
            echo ${{ secrets.DOCKER_PASSWORD }} | docker login ghcr.io -u ${{ secrets.DOCKER_USERNAME }} --password-stdin || { echo "Error logging into GHCR."; exit 1; }

            echo "Stopping and removing old containers..."
            docker compose down --volumes --remove-orphans

            echo "Pulling latest backend image: ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
            docker pull ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} || { echo "Error pulling backend image."; exit 1; }
            docker tag ghcr.io/${{ github.repository_owner }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} nestjs:latest

            echo "Pulling latest frontend image: ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
            docker pull ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} || { echo "Error pulling frontend image."; exit 1; }
            docker tag ghcr.io/${{ github.repository_owner }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} frontend:latest

            echo "Starting services using Docker Compose..."
            docker compose --env-file ./.env up -d --remove-orphans || { echo "Error starting services."; exit 1; }

            echo "Waiting for NestJS backend service to become healthy..."
            for i in {1..15}; do
              HEALTH_STATUS=$(docker inspect -f '{{.State.Health.Status}}' nestjs 2>/dev/null || true)
              if [ "$HEALTH_STATUS" == "healthy" ]; then
                echo "NestJS service is healthy!"
                break
              else
                echo "NestJS service status: $HEALTH_STATUS. Waiting 10 seconds (attempt $i/15)..."
                sleep 10
              fi
              if [ $i -eq 15 ]; then
                echo "NestJS service did not become healthy within the timeout. Deployment might be incomplete."
                exit 1
              fi
            done

            echo "Running Prisma Migrations on the deployed backend service..."
            docker compose exec nestjs npx prisma migrate deploy || { echo "Error running Prisma migrations."; exit 1; }

            echo "Deployment complete!"
